import os
import io
import requests
import cloudinary
import cloudinary.uploader
import firebase_admin
from firebase_admin import credentials, firestore
from fastapi import FastAPI, Request, File, UploadFile, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import List, Dict, Optional
from PIL import Image
import numpy as np
import torch
import cv2
import time
from typing import List, Dict, Optional, Tuple
from pydantic import Field
from sam_label import segment_image,segment_image_for_label
from sam_point_segmentation import get_image_embeddings, generate_mask
from sam_quiz import segment_quiz_image, get_image_without_masks
from dotenv import load_dotenv
import uuid
from ultralytics import FastSAM
import hashlib
from fastapi.middleware.cors import CORSMiddleware

load_dotenv()

# Initialize Cloudinary
cloudinary.config(
    cloud_name=os.getenv('CLOUDINARY_CLOUD_NAME'),
    api_key=os.getenv('CLOUDINARY_API_KEY'),
    api_secret=os.getenv('CLOUDINARY_API_SECRET')
)

# Initialize Firebase
cred = credentials.Certificate('./firebase-credentials-2.json')
firebase_admin.initialize_app(cred)
db = firestore.client()

# Initialize FastAPI app
app = FastAPI()

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Adjust if your frontend port differs
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize FastSAM model - will auto-download if needed
device = 'cuda' if torch.cuda.is_available() else 'cpu'
model = FastSAM('FastSAM-s.pt')  # This will automatically download if not found
model.to(device)

# Define different colors for different regions
HIGHLIGHT_COLORS = [
    (0, 255, 0),    # Green
    (255, 0, 0),    # Red
    (0, 0, 255),    # Blue
    (255, 255, 0),  # Yellow
    (255, 0, 255),  # Magenta
    (0, 255, 255),  # Cyan
]

def get_image_without_masks(image_path, results):
    """
    Creates an image with transparent holes where segments were removed
    """
    img = cv2.imread(image_path)
    if img is None:
        raise ValueError(f"Could not load image from {image_path}")

    rgba = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA)
    if results and len(results[0].masks.data) > 0:
        mask = results[0].masks.data[0].cpu().numpy()
        if mask.shape[:2] != img.shape[:2]:
            mask = cv2.resize(mask, (img.shape[1], img.shape[0]), interpolation=cv2.INTER_NEAREST)
        mask = mask > 0
        rgba[mask] = [0, 0, 0, 0]
    return rgba

def process_image_with_sam(image_path, bounding_box, region_index=0):
    try:
        image = cv2.imread(image_path, cv2.IMREAD_UNCHANGED)
        if image is None:
            raise ValueError(f"Could not load image from {image_path}")

        bbox = {
            'x': max(0, int(float(bounding_box.get('x', bounding_box.get('left', 0))))),
            'y': max(0, int(float(bounding_box.get('y', bounding_box.get('top', 0))))),
            'width': min(int(float(bounding_box.get('width', 0))), image.shape[1]),
            'height': min(int(float(bounding_box.get('height', 0))), image.shape[0])
        }

        print(f"Debug - Processed bbox: {bbox}")

        results = model(
            image_path,
            device=device,
            retina_masks=True,
            imgsz=1024,
            conf=0.4,
            iou=0.9,
            bboxes=[[bbox['x'], bbox['y'], bbox['x'] + bbox['width'], bbox['y'] + bbox['height']]]
        )

        if not results or len(results) == 0 or not hasattr(results[0], 'masks') or len(results[0].masks.data) == 0:
            raise ValueError("No masks generated by the model")

        mask = results[0].masks.data[0].cpu().numpy()
        mask = cv2.resize(mask, (image.shape[1], image.shape[0]), interpolation=cv2.INTER_NEAREST)
        mask = mask > 0

        rgba = cv2.cvtColor(image, cv2.COLOR_BGR2BGRA)
        rgba[~mask] = [0, 0, 0, 0]

        outline = image.copy()
        contours, _ = cv2.findContours(mask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        color = HIGHLIGHT_COLORS[region_index % len(HIGHLIGHT_COLORS)]
        cv2.drawContours(outline, contours, -1, color, 2)

        temp_id = str(uuid.uuid4())[:8]
        temp_paths = {
            'cutout': f'temp_cutout_{temp_id}.png',
            'outline': f'temp_outline_{temp_id}.png'
        }

        cv2.imwrite(temp_paths['cutout'], rgba)
        cv2.imwrite(temp_paths['outline'], outline)

        urls = {}
        for key, path in temp_paths.items():
            response = cloudinary.uploader.upload(
                path,
                resource_type="image",
                allowed_cors_origins=["http://localhost:3000"],
                access_mode="anonymous"
            )
            urls[key] = response['secure_url']
            os.remove(path)

        return {
            'cutout': urls['cutout'],
            'outline': urls['outline'],
            'position': {
                'x': float(bbox['x']),
                'y': float(bbox['y']),
                'width': float(bbox['width']),
                'height': float(bbox['height'])
            },
            'originalSize': {
                'width': image.shape[1],
                'height': image.shape[0]
            }
        }

    except Exception as e:
        print(f"Debug - Error in process_image_with_sam: {str(e)}")
        import traceback
        traceback.print_exc()
        raise

# Pydantic models for request validation
class SegmentRequest(BaseModel):
    image_url: str
    bounding_box: Dict[str, float]
    teacher_id: str
    region_index: Optional[int] = 0

class SaveQuizRequest(BaseModel):
    teacher_id: str
    image_url: str
    segmented_urls: List[str]
    puzzle_outline_url: str
    positions: List[Dict[str, float]]
    meta: Dict

class SegmentQuizRequest(BaseModel):
    image_url: str
    teacher_id: str

class TrackCompletionRequest(BaseModel):
    quiz_id: str
    student_id: Optional[str] = 'anonymous'
    completion_time: str

class ValidatePlacementRequest(BaseModel):
    quiz_id: str
    segment_index: int
    position: Dict[str, float]

class AddNoteRequest(BaseModel):
    image_url: str
    segment_index: int
    note: str
    teacher_id: str
    lesson_id: str

# New Pydantic models for request validation
class PointPrompt(BaseModel):
    x: float
    y: float

class GetEmbeddingRequest(BaseModel):
    image_url: str
    teacher_id: str

class PointSegmentationRequest(BaseModel):
    image_embedding_id: str  # ID to retrieve stored embedding
    points: List[PointPrompt]
    labels: List[int]  # 1 for foreground, 0 for background
    original_size: Tuple[int, int] = Field(..., description="Original image dimensions as (width, height)")

# In-memory storage for embeddings (consider a more persistent solution for production)
image_embeddings_store = {}

# Routes

@app.get('/')
async def home():
    return {"message": "Welcome to Study-Part!"}

@app.post('/upload')
async def upload_file(image: UploadFile = File(...)):
    try:
        if not image:
            raise HTTPException(status_code=400, detail="No image file")

        response = cloudinary.uploader.upload(image.file)
        return {"image_url": response['secure_url']}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/segment')
async def segment_image(data: SegmentRequest):
    try:
        temp_path = f'temp_original_{str(uuid.uuid4())[:8]}.jpg'
        try:
            response = requests.get(data.image_url)
            response.raise_for_status()
            with open(temp_path, 'wb') as f:
                f.write(response.content)

            if not os.path.exists(temp_path):
                raise ValueError("Failed to save downloaded image")

            image = cv2.imread(temp_path)
            if image is None:
                raise ValueError("Failed to read downloaded image")

            processed_data = process_image_with_sam(temp_path, data.bounding_box, data.region_index)

            if not processed_data:
                raise ValueError("Failed to process image")

            return {
                'segmented_urls': [processed_data['cutout']],
                'cutout': processed_data['cutout'],
                'highlighted_outline': processed_data['outline'],
                'original_with_highlight': processed_data['outline'],
                'position': processed_data['position'],
                'originalSize': processed_data['originalSize']
            }
        except requests.exceptions.RequestException as e:
            raise HTTPException(status_code=500, detail=f"Failed to download image: {str(e)}")
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to process image: {str(e)}")
        finally:
            if os.path.exists(temp_path):
                os.remove(temp_path)
    except Exception as e:
        print(f"Debug - General error: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/segment_label')
async def segment_label(data: SegmentRequest):
    try:
        # Download the image from the provided URL
        temp_path = f'temp_original_{str(uuid.uuid4())[:8]}.jpg'
        try:
            response = requests.get(data.image_url)
            response.raise_for_status()
            with open(temp_path, 'wb') as f:
                f.write(response.content)

            if not os.path.exists(temp_path):
                raise ValueError("Failed to save downloaded image")

            image = cv2.imread(temp_path)
            if image is None:
                raise ValueError("Failed to read downloaded image")

            # Call the segment_image_for_label function from sam_label.py
            mask_urls, position = segment_image_for_label(
                temp_path,
                [
                    data.bounding_box['x'],
                    data.bounding_box['y'],
                    data.bounding_box['width'],
                    data.bounding_box['height']
                ],
                model,
                region_index=data.region_index  # Pass the region_index
            )

            # Upload the mask to Cloudinary
            mask_url = None
            if mask_urls:
                with open(mask_urls[0].lstrip('/'), 'rb') as mask_file:
                    upload_result = cloudinary.uploader.upload(
                        mask_file,
                        resource_type="image",
                        allowed_cors_origins=["http://localhost:3000"],
                        access_mode="anonymous"
                    )
                    mask_url = upload_result['secure_url']

            return {
                'mask_url': mask_url,  # URL to the translucent mask
                'position': position,
                'originalSize': {
                    'width': image.shape[1],
                    'height': image.shape[0]
                }
            }
        except requests.exceptions.RequestException as e:
            raise HTTPException(status_code=500, detail=f"Failed to download image: {str(e)}")
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to process image: {str(e)}")
        finally:
            if os.path.exists(temp_path):
                os.remove(temp_path)
    except Exception as e:
        print(f"Debug - General error: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/save_quiz')
async def save_quiz(data: SaveQuizRequest):
    try:
        quiz_ref = db.collection('quizzes').document()
        quiz_data = {
            'teacher_id': data.teacher_id,
            'image_url': data.image_url,
            'segments': data.segmented_urls,
            'puzzle_outline': data.puzzle_outline_url,
            'positions': data.positions,
            'meta': data.meta,
            'created_at': firestore.SERVER_TIMESTAMP
        }
        quiz_ref.set(quiz_data)

        teacher_ref = db.collection('teachers').document(data.teacher_id)
        teacher_ref.update({
            'quizzes': firestore.ArrayUnion([quiz_ref.id])
        })

        return {'quiz_id': quiz_ref.id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/segment_quiz')
async def segment_quiz(data: SegmentQuizRequest):
    try:
        response = requests.get(data.image_url)
        temp_image_path = "temp_quiz_image.jpg"
        with open(temp_image_path, 'wb') as f:
            f.write(response.content)

        const_output = segment_quiz_image(temp_image_path)
        segmented_cutouts = const_output[0]
        puzzle_outline = const_output[1]
        positions = const_output[2]

        segmented_urls = []
        for idx, cutout in enumerate(segmented_cutouts):
            cutout_image = Image.fromarray(cutout.astype(np.uint8))
            segmented_image_buffer = io.BytesIO()
            cutout_image.save(segmented_image_buffer, format='PNG')
            segmented_image_buffer.seek(0)
            upload_result = cloudinary.uploader.upload(
                segmented_image_buffer,
                public_id=f'segmented_quiz_{idx}',
                format="png"
            )
            segmented_urls.append(upload_result['secure_url'])

        os.remove(temp_image_path)

        puzzle_outline_rgba = cv2.cvtColor(puzzle_outline, cv2.COLOR_BGRA2RGBA)
        pil_outline = Image.fromarray(puzzle_outline_rgba)
        outline_buffer = io.BytesIO()
        pil_outline.save(outline_buffer, format='PNG')
        outline_buffer.seek(0)
        upload_result_outline = cloudinary.uploader.upload(
            outline_buffer,
            public_id=f'puzzle_outline_{uuid.uuid4().hex[:8]}',
            format="png"
        )
        puzzle_outline_url = upload_result_outline['secure_url']

        return {
            'segmented_urls': segmented_urls,
            'puzzle_outline_url': puzzle_outline_url,
            'positions': positions
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get('/get_all_quizzes')
async def get_all_quizzes():
    try:
        quizzes_ref = db.collection('quizzes')
        quizzes = []
        for doc in quizzes_ref.stream():
            quiz_data = doc.to_dict()
            quizzes.append({
                'id': doc.id,
                'meta': quiz_data.get('meta', {}),
                'created_at': quiz_data.get('created_at')
            })
        quizzes.sort(key=lambda x: x.get('created_at', 0), reverse=True)
        return {'quizzes': quizzes}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get('/get_quiz/{quiz_id}')
async def get_quiz(quiz_id: str):
    try:
        quiz_ref = db.collection('quizzes').document(quiz_id)
        quiz_data = quiz_ref.get()
        if not quiz_data.exists:
            raise HTTPException(status_code=404, detail="Quiz not found")
        quiz_dict = quiz_data.to_dict()
        return {
            'meta': quiz_dict.get('meta', {}),
            'image_url': quiz_dict.get('image_url', ''),
            'segments': quiz_dict.get('segments', []),
            'puzzle_outline': quiz_dict.get('puzzle_outline', ''),
            'positions': quiz_dict.get('positions', []),
            'original_size': quiz_dict.get('original_size', {'width': 800, 'height': 600})
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/track_completion')
async def track_completion(data: TrackCompletionRequest):
    try:
        completion_ref = db.collection('quiz_completions').document()
        completion_data = {
            'quiz_id': data.quiz_id,
            'student_id': data.student_id,
            'completion_time': data.completion_time,
            'completed_at': firestore.SERVER_TIMESTAMP
        }
        completion_ref.set(completion_data)
        return {'success': True}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/validate_placement')
async def validate_placement(data: ValidatePlacementRequest):
    try:
        quiz_ref = db.collection('quizzes').document(data.quiz_id)
        quiz_data = quiz_ref.get().to_dict()
        original_pos = quiz_data['positions'][data.segment_index]

        tolerance = 0.1
        is_correct = (
            abs(data.position['x'] - original_pos['x']) < original_pos['width'] * tolerance and
            abs(data.position['y'] - original_pos['y']) < original_pos['height'] * tolerance
        )
        return {'correct': is_correct}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/add_note')
async def add_note(data: AddNoteRequest):
    try:
        segment_ref = db.collection('Teachers').document(data.teacher_id) \
                       .collection('Lessons').document(data.lesson_id) \
                       .collection('Segments').document(f'segment_{data.segment_index}')
        segment_doc = segment_ref.get()
        if not segment_doc.exists:
            segment_ref.set({
                'boundingBox': {},
                'segmentCoordinates': [],
                'notes': data.note,
                'highlightedOutlineUrl': ''
            })
        else:
            segment_ref.update({'notes': data.note})
        return {"message": "Note added successfully!"}
    except Exception as e:
        print(f"Error in add_note: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get('/get_lessons')
async def get_lessons(teacher_id: str):
    try:
        if not teacher_id:
            raise HTTPException(status_code=400, detail="Missing teacher_id parameter")
        lessons_ref = db.collection('Teachers').document(teacher_id).collection('Lessons')
        lessons_docs = lessons_ref.stream()
        lessons_list = []
        for lesson_doc in lessons_docs:
            lesson_data = lesson_doc.to_dict()
            lesson_id = lesson_doc.id
            segments_ref = lessons_ref.document(lesson_id).collection('Segments')
            segments_docs = segments_ref.stream()
            segments = [{'id': seg_doc.id, **seg_doc.to_dict()} for seg_doc in segments_docs]
            lessons_list.append({
                'id': lesson_id,
                'originalImageUrl': lesson_data.get('originalImageUrl', ''),
                'title': lesson_data.get('title', f"Lesson {lesson_data.get('createdAt', '')}"),
                'createdAt': lesson_data.get('createdAt', ''),
                'segments': segments
            })
        return {'lessons': lessons_list}
    except Exception as e:
        print(f"Error in get_lessons: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
    
@app.post('/get_image_embedding')
async def get_embedding(data: GetEmbeddingRequest):
    try:
        # Download the image from URL
        temp_path = f'temp_original_{str(uuid.uuid4())[:8]}.jpg'
        try:
            response = requests.get(data.image_url)
            response.raise_for_status()
            with open(temp_path, 'wb') as f:
                f.write(response.content)

            if not os.path.exists(temp_path):
                raise ValueError("Failed to save downloaded image")

            # Get image embeddings
            embedding = get_image_embeddings(temp_path)
            
            # Generate a unique ID for this embedding
            embedding_id = str(uuid.uuid4())
            
            # Store the embedding with the ID and original image URL
            image_embeddings_store[embedding_id] = {
                'embedding': embedding,
                'teacher_id': data.teacher_id,
                'created_at': time.time(),
                'image_url': data.image_url   # new field for original image URL
            }
            
            return {
                'embedding_id': embedding_id,
                'success': True,
                'message': 'Image embedding created successfully'
            }
        except requests.exceptions.RequestException as e:
            raise HTTPException(status_code=500, detail=f"Failed to download image: {str(e)}")
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to process image: {str(e)}")
        finally:
            if os.path.exists(temp_path):
                os.remove(temp_path)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/segment_with_points')
async def segment_with_points_route(data: PointSegmentationRequest):
    try:
        # Retrieve the stored embedding
        if data.image_embedding_id not in image_embeddings_store:
            raise HTTPException(status_code=404, detail="Image embedding not found. It may have expired. Please generate a new embedding.")
        
        embedding_data = image_embeddings_store[data.image_embedding_id]
        image_embedding = embedding_data['embedding']
        
        # Generate binary mask
        points = [[point.x, point.y] for point in data.points]
        # Generate binary mask
        mask = generate_mask(
            image_embedding=image_embedding,
            points=points,
            labels=data.labels,
            original_size=data.original_size
        )

        # Retrieve the original image via stored URL
        original_url = embedding_data.get('image_url')
        response = requests.get(original_url)
        temp_orig = "temp_orig_image.jpg"
        with open(temp_orig, "wb") as f:
            f.write(response.content)

        # Load the original image using cv2 in color mode
        original_image = cv2.imread(temp_orig, cv2.IMREAD_COLOR)
        os.remove(temp_orig)

        # Resize the mask to match the original image dimensions
        mask = cv2.resize(mask, (original_image.shape[1], original_image.shape[0]))
        mask_bool = mask > 0  # Convert to boolean mask

        # Define a color for the mask, e.g., cyan (BGR format for OpenCV)
        color = (0, 255, 255)

        # Create a colored mask (RGB channels)
        colored_mask = np.zeros_like(original_image)  # Shape: (height, width, 3)
        for c in range(3):
            colored_mask[:, :, c] = np.where(mask_bool, color[c], 0)

        # Create RGBA mask (height, width, 4)
        mask_rgba = np.zeros((*original_image.shape[:2], 4), dtype=np.uint8)
        mask_rgba[:, :, :3] = colored_mask  # RGB channels
        mask_rgba[:, :, 3] = mask  # Alpha channel (0 or 255)

        # Convert to PIL Image and save to buffer
        pil_mask = Image.fromarray(mask_rgba, 'RGBA')
        buffer = io.BytesIO()
        pil_mask.save(buffer, format="PNG")
        buffer.seek(0)

        # Upload to Cloudinary
        upload_result = cloudinary.uploader.upload(
            buffer,
            resource_type="image",
            allowed_cors_origins=["http://localhost:3000"],
            access_mode="anonymous"
        )
        mask_url = upload_result['secure_url']

        return {
            'mask_url': mask_url,
            'success': True
        }
    except Exception as e:
        print(f"Debug - Error in segment_with_points: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/get_point_cutouts')
async def get_point_cutouts(data: PointSegmentationRequest):
    try:
        # Check if the embedding exists
        if data.image_embedding_id not in image_embeddings_store:
            raise HTTPException(status_code=404, detail="Image embedding not found. It may have expired. Please generate a new embedding.")
        
        embedding_data = image_embeddings_store[data.image_embedding_id]
        image_embedding = embedding_data['embedding']
        
        # Generate the binary mask from points and labels
        points = [[point.x, point.y] for point in data.points]
        mask = generate_mask(
            image_embedding=image_embedding,
            points=points,
            labels=data.labels,
            original_size=data.original_size
        )

        # Download the original image from the stored URL
        original_url = embedding_data.get('image_url')
        response = requests.get(original_url)
        temp_file = "temp_orig_image.jpg"
        with open(temp_file, "wb") as f:
            f.write(response.content)

        # Load the image in color mode
        original_image = cv2.imread(temp_file, cv2.IMREAD_COLOR)
        os.remove(temp_file)

        # Resize the mask to match the original image size
        mask = cv2.resize(mask, (original_image.shape[1], original_image.shape[0]), interpolation=cv2.INTER_NEAREST)

        # Find the bounding box of the mask
        coords = cv2.findNonZero(mask)
        if coords is None:
            raise ValueError("No valid mask generated")
        x, y, w, h = cv2.boundingRect(coords)

        # Create the cutout
        img_crop = original_image[y:y+h, x:x+w]  # Crop the image (BGR)
        mask_crop = mask[y:y+h, x:x+w]           # Crop the mask
        img_crop_rgba = cv2.cvtColor(img_crop, cv2.COLOR_BGR2RGBA)  # Convert to RGBA
        img_crop_rgba[:, :, 3] = mask_crop  # Set alpha channel (255 where mask is True)

        # Create the puzzle outline
        original_rgba = cv2.cvtColor(original_image, cv2.COLOR_BGR2RGBA)  # Full image to RGBA
        alpha_channel = np.where(mask == 0, 255, 0).astype(np.uint8)      # Transparent where mask is True
        original_rgba[:, :, 3] = alpha_channel

        # Convert to PIL Images for PNG saving
        pil_cutout = Image.fromarray(cv2.cvtColor(img_crop_rgba, cv2.COLOR_BGRA2RGBA), 'RGBA')
        pil_outline = Image.fromarray(cv2.cvtColor(original_rgba, cv2.COLOR_BGRA2RGBA), 'RGBA')

        # Upload the cutout to Cloudinary
        cutout_buffer = io.BytesIO()
        pil_cutout.save(cutout_buffer, format='PNG')
        cutout_buffer.seek(0)
        upload_result_cutout = cloudinary.uploader.upload(
            cutout_buffer,
            public_id=f'cutout_{uuid.uuid4().hex[:8]}',
            format="png"
        )
        cutout_url = upload_result_cutout['secure_url']

        # Upload the puzzle outline to Cloudinary
        outline_buffer = io.BytesIO()
        pil_outline.save(outline_buffer, format='PNG')
        outline_buffer.seek(0)
        upload_result_outline = cloudinary.uploader.upload(
            outline_buffer,
            public_id=f'puzzle_outline_{uuid.uuid4().hex[:8]}',
            format="png"
        )
        puzzle_outline_url = upload_result_outline['secure_url']

        # Define the position of the cutout
        position = {
            'x': x,
            'y': y,
            'width': w,
            'height': h,
            'original_width': original_image.shape[1],
            'original_height': original_image.shape[0]
        }

        # Return the response
        return {
            'segmented_urls': [cutout_url],         # Single cutout URL in a list
            'puzzle_outline_url': puzzle_outline_url,
            'positions': [position]                 # Single position in a list
        }
    except Exception as e:
        print(f"Error in get_point_cutouts: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Optional route to handle cleanup of embeddings
@app.delete('/image_embedding/{embedding_id}')
async def delete_embedding(embedding_id: str):
    if embedding_id in image_embeddings_store:
        del image_embeddings_store[embedding_id]
        return {"message": "Embedding deleted successfully"}
    raise HTTPException(status_code=404, detail="Embedding not found")

# Maintenance endpoint to cleanup old embeddings (could also be a background task)
@app.post('/cleanup_embeddings')
async def cleanup_embeddings(max_age_seconds: int = 3600):  # Default: clean embeddings older than 1 hour
    current_time = time.time()
    expired_ids = [
        embedding_id 
        for embedding_id, data in image_embeddings_store.items() 
        if current_time - data['created_at'] > max_age_seconds
    ]
    
    for embedding_id in expired_ids:
        del image_embeddings_store[embedding_id]
    
    return {"message": f"Cleaned up {len(expired_ids)} expired embeddings"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)